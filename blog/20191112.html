<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>1、Reflect | blog</title>
    <meta name="description" content="Just playing around">
    <link rel="icon" href="/vue-blog/logo.png">
    
    <link rel="preload" href="/vue-blog/assets/css/0.styles.ea32b67c.css" as="style"><link rel="preload" href="/vue-blog/assets/js/app.90d19ee5.js" as="script"><link rel="preload" href="/vue-blog/assets/js/5.126d9e8a.js" as="script"><link rel="prefetch" href="/vue-blog/assets/js/10.226c6371.js"><link rel="prefetch" href="/vue-blog/assets/js/11.5e2e60fd.js"><link rel="prefetch" href="/vue-blog/assets/js/12.302cf6c4.js"><link rel="prefetch" href="/vue-blog/assets/js/13.15aff0ae.js"><link rel="prefetch" href="/vue-blog/assets/js/2.d3a3f049.js"><link rel="prefetch" href="/vue-blog/assets/js/3.327c83e2.js"><link rel="prefetch" href="/vue-blog/assets/js/4.d6079133.js"><link rel="prefetch" href="/vue-blog/assets/js/6.06834e62.js"><link rel="prefetch" href="/vue-blog/assets/js/7.7c2c6a95.js"><link rel="prefetch" href="/vue-blog/assets/js/8.e56a1002.js"><link rel="prefetch" href="/vue-blog/assets/js/9.09e3f7d8.js">
    <link rel="stylesheet" href="/vue-blog/assets/css/0.styles.ea32b67c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/vue-blog/" class="home-link router-link-active"><!----> <span class="site-name">blog</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/vue-blog/" class="nav-link">Home</a></div> <a href="https://github.com/beijingxiayule/ypwang.github.io.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    My GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/vue-blog/" class="nav-link">Home</a></div> <a href="https://github.com/beijingxiayule/ypwang.github.io.git" target="_blank" rel="noopener noreferrer" class="repo-link">
    My GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><a href="/vue-blog/blog/20191111.html" class="sidebar-link">玩转for循环</a></li><li><a href="/vue-blog/blog/20191112.html" aria-current="page" class="active sidebar-link">Reflect与Proxy</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/vue-blog/blog/20191129.html" class="sidebar-link">vu常见面试题</a></li><li><a href="/vue-blog/blog/20200106.html" class="sidebar-link">层叠上下文与层叠顺序</a></li><li><a href="/vue-blog/blog/20200107.html" class="sidebar-link">setTimeout的第三个参数</a></li><li><a href="/vue-blog/blog/20200108.html" class="sidebar-link">认识 URLSearchParams</a></li></ul> </div> <div class="page"> <div class="content"><h3 id="_1、reflect"><a href="#_1、reflect" class="header-anchor">#</a> 1、Reflect</h3> <h4 id="reflect对象与proxy对象一样，也是-es6-为了操作对象而提供的新-api。"><a href="#reflect对象与proxy对象一样，也是-es6-为了操作对象而提供的新-api。" class="header-anchor">#</a> Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。</h4> <h5 id="reflect对象的设计目的有这样几个："><a href="#reflect对象的设计目的有这样几个：" class="header-anchor">#</a> Reflect对象的设计目的有这样几个：</h5> <h6 id="①：将object对象的一些明显属于语言内部的方法（比如object-defineproperty），放到reflect对象上。现阶段，某些方法同时在object和reflect对象上部署，未来的新方法将只部署在reflect对象上。也就是说，从reflect对象上可以拿到语言内部的方法。"><a href="#①：将object对象的一些明显属于语言内部的方法（比如object-defineproperty），放到reflect对象上。现阶段，某些方法同时在object和reflect对象上部署，未来的新方法将只部署在reflect对象上。也就是说，从reflect对象上可以拿到语言内部的方法。" class="header-anchor">#</a> ①：将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。</h6> <h6 id="②：修改某些object方法的返回结果，让其变得更合理。比如，object-defineproperty-obj-name-desc-在无法定义属性时，会抛出一个错误，而reflect-defineproperty-obj-name-desc-则会返回false。"><a href="#②：修改某些object方法的返回结果，让其变得更合理。比如，object-defineproperty-obj-name-desc-在无法定义属性时，会抛出一个错误，而reflect-defineproperty-obj-name-desc-则会返回false。" class="header-anchor">#</a> ②：修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。</h6> <pre><code>var obj = {};
Object.defineProperty(obj, 'name',{value:'wangwang',writable:false});


Object.defineProperty(obj, 'name',{value:'wang'});         // error
Reflect.defineProperty(obj, &quot;name&quot;, {value:&quot;wang&quot;});     // false

(对象的什么属性不能定义？我并没有找到，自己用writable模拟了一个！)
</code></pre> <h6 id="③：让object操作都变成函数行为。某些object操作是命令式，比如name-in-obj和delete-obj-name-，而reflect-has-obj-name-和reflect-deleteproperty-obj-name-让它们变成了函数行为。"><a href="#③：让object操作都变成函数行为。某些object操作是命令式，比如name-in-obj和delete-obj-name-，而reflect-has-obj-name-和reflect-deleteproperty-obj-name-让它们变成了函数行为。" class="header-anchor">#</a> ③：让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。</h6> <pre><code>var obj = {name: &quot;wangwang&quot;};


// 判断对象有没有这个属性key
&quot;name&quot; in obj;
      Reflect.has(obj, &quot;name&quot;);

// 删除对象的某个属性
delete obj.name;
Reflect.deleteProperty(obj,&quot;name&quot;);
</code></pre> <h6 id="reflect对象一共有-13-个静态方法。"><a href="#reflect对象一共有-13-个静态方法。" class="header-anchor">#</a> Reflect对象一共有 13 个静态方法。</h6> <pre><code>Reflect.apply(target, thisArg, args)
Reflect.construct(target, args)
Reflect.get(target, name, receiver)
Reflect.set(target, name, value, receiver)
Reflect.defineProperty(target, name, desc)
Reflect.deleteProperty(target, name)
Reflect.has(target, name)
Reflect.ownKeys(target)
Reflect.isExtensible(target)
Reflect.preventExtensions(target)
Reflect.getOwnPropertyDescriptor(target, name)
Reflect.getPrototypeOf(target)
Reflect.setPrototypeOf(target, prototype)
</code></pre> <h6 id="reflect-get-target-name-receiver"><a href="#reflect-get-target-name-receiver" class="header-anchor">#</a> Reflect.get(target, name, receiver)</h6> <pre><code>Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。
target：目标对象，name：对象key值，receiver：可选，如果name属性部署了读取         函数（getter），则读取函数的this绑定receiver

var obj = {name: &quot;wangwang&quot;};
Reflect.get(obj,&quot;name&quot;);

// 一个包含receiver的例子
var obj = {
  a: 1,
  b: 2,
  get c() {
    return this.a + this.b;
  },
};
var obj1 = {
  a: 4,
  b: 4,
};
Reflect.get(obj, 'c', obj1);
</code></pre> <h6 id="reflect-set-target-name-value-receiver"><a href="#reflect-set-target-name-value-receiver" class="header-anchor">#</a> Reflect.set(target, name, value, receiver)</h6> <pre><code>Reflect.set方法设置target对象的name属性等于value。如果name属性设置了赋值函数，     则赋值函数的this绑定receiver。
target：目标对象，name：对象key值，value：值，receiver：可选，如果name属性部署了赋值函数（setter），则读取函数的this绑定receiver

var obj = {
  a: 1,
  b: 2
};
obj.a;
  Reflect.set(obj, 'a', 2);
     obj.a;

// 一个包含receiver的例子
var obj = {
    a: 1,
    b: 2,
    set c(value) {
	  return this.a = value;
    }
};

var obj1 = {a:8};
 Reflect.set(obj,&quot;c&quot;,11,obj1);
</code></pre> <h6 id="④：reflect对象的方法与proxy对象的方法一一对应，只要是proxy对象的方法，就能在reflect对象上找到对应的方法。这就让proxy对象可以方便地调用对应的reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管proxy怎么修改默认行为，你总可以在reflect上获取默认行为。"><a href="#④：reflect对象的方法与proxy对象的方法一一对应，只要是proxy对象的方法，就能在reflect对象上找到对应的方法。这就让proxy对象可以方便地调用对应的reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管proxy怎么修改默认行为，你总可以在reflect上获取默认行为。" class="header-anchor">#</a> ④：Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。</h6> <h3 id="_2、proxy"><a href="#_2、proxy" class="header-anchor">#</a> 2、Proxy</h3> <h5 id="proxy-可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。proxy-这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。"><a href="#proxy-可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。proxy-这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。" class="header-anchor">#</a> Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</h5> <h5 id="语法：-var-obj-new-proxy-target-handler"><a href="#语法：-var-obj-new-proxy-target-handler" class="header-anchor">#</a> 语法： var obj = new Proxy(target, handler);</h5> <p>Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p> <h6 id="通过object-defineproperty来监测数据变更"><a href="#通过object-defineproperty来监测数据变更" class="header-anchor">#</a> 通过Object.defineProperty来监测数据变更</h6> <pre><code>var obj = {&quot;name&quot;:&quot;wangwang&quot;,&quot;age&quot;: 18};
Object.keys(obj).forEach(function(key) {
	let val = obj[key];
	Object.defineProperty(obj,key,{
		get() {
			console.log(`get obj ${key}`)
			return val
        },
		set(newVal) {
			console.log(`set obj ${key}`)
			return val = newVal
		}
	});
});
</code></pre> <h6 id="通过proxy来代理数据变更"><a href="#通过proxy来代理数据变更" class="header-anchor">#</a> 通过Proxy来代理数据变更</h6> <pre><code>var obj = {&quot;name&quot;:&quot;wangwang&quot;,&quot;age&quot;: 18};
var newObj = new Proxy(obj, {
  get: function(target, key, receiver) {
    console.log(`get obj ${key}!`);
    return Reflect.get(target, key, receiver);
  },
  set: function(target, key, value, receiver) {
    console.log(`set obj ${key}!`);
    return Reflect.set(target, key, value, receiver);
  },
});
</code></pre> <h6 id="vue-对于数组的一些处理"><a href="#vue-对于数组的一些处理" class="header-anchor">#</a> vue 对于数组的一些处理</h6> <pre><code>var arr = [1,2,3,4,5];
Object.keys(arr).forEach(function(key) {
	let val = arr[key];
	Object.defineProperty(arr,key,{
		get() {
			console.log(`get arr ${key}`)
			return val	
		},
		set(newVal) {
			console.log(`set arr ${key}`)
			return val = newVal
		},
	})
});

其实，通过下标来改变数组的某一项是能够监听到的，vue自己做了骚操作
https://segmentfault.com/a/1190000015783546
但是，数组的类似于push、pop、shift、unshift....之类的方法监听不到
</code></pre> <h6 id="利用proxy来代理数组，试试看能不能监听数组变更"><a href="#利用proxy来代理数组，试试看能不能监听数组变更" class="header-anchor">#</a> 利用proxy来代理数组，试试看能不能监听数组变更</h6> <pre><code>var arr = [1,2,3,4,5];
var newArr = new Proxy(arr,{
	get: function (arr, key, receiver) {
        console.log(`getting ${key}!`);
        return Reflect.get(arr, key, receiver);
  	},
  	set: function (arr, key, value, receiver) {
    	console.log(`setting ${key}!`);
    	return Reflect.set(arr, key, value, receiver);
  	}
});
</code></pre></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/vue-blog/blog/20191111.html" class="prev">
          玩转for循环
        </a></span> <span class="next"><a href="/vue-blog/blog/20191129.html">
          vu常见面试题
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/vue-blog/assets/js/app.90d19ee5.js" defer></script><script src="/vue-blog/assets/js/5.126d9e8a.js" defer></script>
  </body>
</html>
