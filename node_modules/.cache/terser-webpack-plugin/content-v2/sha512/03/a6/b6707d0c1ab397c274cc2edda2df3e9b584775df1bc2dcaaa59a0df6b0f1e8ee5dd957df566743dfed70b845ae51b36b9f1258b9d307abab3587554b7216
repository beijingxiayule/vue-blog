{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{212:function(e,t,r){\"use strict\";r.r(t);var a=r(0),n=Object(a.a)({},(function(){var e=this,t=e.$createElement,r=e._self._c||t;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[r(\"h3\",{attrs:{id:\"_1、reflect\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1、reflect\"}},[e._v(\"#\")]),e._v(\" 1、Reflect\")]),e._v(\" \"),r(\"h4\",{attrs:{id:\"reflect对象与proxy对象一样，也是-es6-为了操作对象而提供的新-api。\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reflect对象与proxy对象一样，也是-es6-为了操作对象而提供的新-api。\"}},[e._v(\"#\")]),e._v(\" Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。\")]),e._v(\" \"),r(\"h5\",{attrs:{id:\"reflect对象的设计目的有这样几个：\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reflect对象的设计目的有这样几个：\"}},[e._v(\"#\")]),e._v(\" Reflect对象的设计目的有这样几个：\")]),e._v(\" \"),r(\"h6\",{attrs:{id:\"①：将object对象的一些明显属于语言内部的方法（比如object-defineproperty），放到reflect对象上。现阶段，某些方法同时在object和reflect对象上部署，未来的新方法将只部署在reflect对象上。也就是说，从reflect对象上可以拿到语言内部的方法。\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#①：将object对象的一些明显属于语言内部的方法（比如object-defineproperty），放到reflect对象上。现阶段，某些方法同时在object和reflect对象上部署，未来的新方法将只部署在reflect对象上。也就是说，从reflect对象上可以拿到语言内部的方法。\"}},[e._v(\"#\")]),e._v(\" ①：将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。\")]),e._v(\" \"),r(\"h6\",{attrs:{id:\"②：修改某些object方法的返回结果，让其变得更合理。比如，object-defineproperty-obj-name-desc-在无法定义属性时，会抛出一个错误，而reflect-defineproperty-obj-name-desc-则会返回false。\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#②：修改某些object方法的返回结果，让其变得更合理。比如，object-defineproperty-obj-name-desc-在无法定义属性时，会抛出一个错误，而reflect-defineproperty-obj-name-desc-则会返回false。\"}},[e._v(\"#\")]),e._v(\" ②：修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。\")]),e._v(\" \"),r(\"pre\",[r(\"code\",[e._v(\"var obj = {};\\nObject.defineProperty(obj, 'name',{value:'wangwang',writable:false});\\n\\n\\nObject.defineProperty(obj, 'name',{value:'wang'});         // error\\nReflect.defineProperty(obj, \\\"name\\\", {value:\\\"wang\\\"});     // false\\n\\n(对象的什么属性不能定义？我并没有找到，自己用writable模拟了一个！)\\n\")])]),e._v(\" \"),r(\"h6\",{attrs:{id:\"③：让object操作都变成函数行为。某些object操作是命令式，比如name-in-obj和delete-obj-name-，而reflect-has-obj-name-和reflect-deleteproperty-obj-name-让它们变成了函数行为。\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#③：让object操作都变成函数行为。某些object操作是命令式，比如name-in-obj和delete-obj-name-，而reflect-has-obj-name-和reflect-deleteproperty-obj-name-让它们变成了函数行为。\"}},[e._v(\"#\")]),e._v(\" ③：让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。\")]),e._v(\" \"),r(\"pre\",[r(\"code\",[e._v('var obj = {name: \"wangwang\"};\\n\\n\\n// 判断对象有没有这个属性key\\n\"name\" in obj;\\n      Reflect.has(obj, \"name\");\\n\\n// 删除对象的某个属性\\ndelete obj.name;\\nReflect.deleteProperty(obj,\"name\");\\n')])]),e._v(\" \"),r(\"h6\",{attrs:{id:\"reflect对象一共有-13-个静态方法。\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reflect对象一共有-13-个静态方法。\"}},[e._v(\"#\")]),e._v(\" Reflect对象一共有 13 个静态方法。\")]),e._v(\" \"),r(\"pre\",[r(\"code\",[e._v(\"Reflect.apply(target, thisArg, args)\\nReflect.construct(target, args)\\nReflect.get(target, name, receiver)\\nReflect.set(target, name, value, receiver)\\nReflect.defineProperty(target, name, desc)\\nReflect.deleteProperty(target, name)\\nReflect.has(target, name)\\nReflect.ownKeys(target)\\nReflect.isExtensible(target)\\nReflect.preventExtensions(target)\\nReflect.getOwnPropertyDescriptor(target, name)\\nReflect.getPrototypeOf(target)\\nReflect.setPrototypeOf(target, prototype)\\n\")])]),e._v(\" \"),r(\"h6\",{attrs:{id:\"reflect-get-target-name-receiver\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reflect-get-target-name-receiver\"}},[e._v(\"#\")]),e._v(\" Reflect.get(target, name, receiver)\")]),e._v(\" \"),r(\"pre\",[r(\"code\",[e._v('Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。\\ntarget：目标对象，name：对象key值，receiver：可选，如果name属性部署了读取         函数（getter），则读取函数的this绑定receiver\\n\\nvar obj = {name: \"wangwang\"};\\nReflect.get(obj,\"name\");\\n\\n// 一个包含receiver的例子\\nvar obj = {\\n  a: 1,\\n  b: 2,\\n  get c() {\\n    return this.a + this.b;\\n  },\\n};\\nvar obj1 = {\\n  a: 4,\\n  b: 4,\\n};\\nReflect.get(obj, \\'c\\', obj1);\\n')])]),e._v(\" \"),r(\"h6\",{attrs:{id:\"reflect-set-target-name-value-receiver\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#reflect-set-target-name-value-receiver\"}},[e._v(\"#\")]),e._v(\" Reflect.set(target, name, value, receiver)\")]),e._v(\" \"),r(\"pre\",[r(\"code\",[e._v(\"Reflect.set方法设置target对象的name属性等于value。如果name属性设置了赋值函数，     则赋值函数的this绑定receiver。\\ntarget：目标对象，name：对象key值，value：值，receiver：可选，如果name属性部署了赋值函数（setter），则读取函数的this绑定receiver\\n\\nvar obj = {\\n  a: 1,\\n  b: 2\\n};\\nobj.a;\\n  Reflect.set(obj, 'a', 2);\\n     obj.a;\\n\\n// 一个包含receiver的例子\\nvar obj = {\\n    a: 1,\\n    b: 2,\\n    set c(value) {\\n\\t  return this.a = value;\\n    }\\n};\\n\\nvar obj1 = {a:8};\\n Reflect.set(obj,\\\"c\\\",11,obj1);\\n\")])]),e._v(\" \"),r(\"h6\",{attrs:{id:\"④：reflect对象的方法与proxy对象的方法一一对应，只要是proxy对象的方法，就能在reflect对象上找到对应的方法。这就让proxy对象可以方便地调用对应的reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管proxy怎么修改默认行为，你总可以在reflect上获取默认行为。\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#④：reflect对象的方法与proxy对象的方法一一对应，只要是proxy对象的方法，就能在reflect对象上找到对应的方法。这就让proxy对象可以方便地调用对应的reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管proxy怎么修改默认行为，你总可以在reflect上获取默认行为。\"}},[e._v(\"#\")]),e._v(\" ④：Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。\")]),e._v(\" \"),r(\"h3\",{attrs:{id:\"_2、proxy\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2、proxy\"}},[e._v(\"#\")]),e._v(\" 2、Proxy\")]),e._v(\" \"),r(\"h5\",{attrs:{id:\"proxy-可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。proxy-这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#proxy-可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。proxy-这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\"}},[e._v(\"#\")]),e._v(\" Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。\")]),e._v(\" \"),r(\"h5\",{attrs:{id:\"语法：-var-obj-new-proxy-target-handler\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#语法：-var-obj-new-proxy-target-handler\"}},[e._v(\"#\")]),e._v(\" 语法： var obj = new Proxy(target, handler);\")]),e._v(\" \"),r(\"p\",[e._v(\"Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。\")]),e._v(\" \"),r(\"h6\",{attrs:{id:\"通过object-defineproperty来监测数据变更\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#通过object-defineproperty来监测数据变更\"}},[e._v(\"#\")]),e._v(\" 通过Object.defineProperty来监测数据变更\")]),e._v(\" \"),r(\"pre\",[r(\"code\",[e._v('var obj = {\"name\":\"wangwang\",\"age\": 18};\\nObject.keys(obj).forEach(function(key) {\\n\\tlet val = obj[key];\\n\\tObject.defineProperty(obj,key,{\\n\\t\\tget() {\\n\\t\\t\\tconsole.log(`get obj ${key}`)\\n\\t\\t\\treturn val\\n        },\\n\\t\\tset(newVal) {\\n\\t\\t\\tconsole.log(`set obj ${key}`)\\n\\t\\t\\treturn val = newVal\\n\\t\\t}\\n\\t});\\n});\\n')])]),e._v(\" \"),r(\"h6\",{attrs:{id:\"通过proxy来代理数据变更\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#通过proxy来代理数据变更\"}},[e._v(\"#\")]),e._v(\" 通过Proxy来代理数据变更\")]),e._v(\" \"),r(\"pre\",[r(\"code\",[e._v('var obj = {\"name\":\"wangwang\",\"age\": 18};\\nvar newObj = new Proxy(obj, {\\n  get: function(target, key, receiver) {\\n    console.log(`get obj ${key}!`);\\n    return Reflect.get(target, key, receiver);\\n  },\\n  set: function(target, key, value, receiver) {\\n    console.log(`set obj ${key}!`);\\n    return Reflect.set(target, key, value, receiver);\\n  },\\n});\\n')])]),e._v(\" \"),r(\"h6\",{attrs:{id:\"vue-对于数组的一些处理\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#vue-对于数组的一些处理\"}},[e._v(\"#\")]),e._v(\" vue 对于数组的一些处理\")]),e._v(\" \"),r(\"pre\",[r(\"code\",[e._v(\"var arr = [1,2,3,4,5];\\nObject.keys(arr).forEach(function(key) {\\n\\tlet val = arr[key];\\n\\tObject.defineProperty(arr,key,{\\n\\t\\tget() {\\n\\t\\t\\tconsole.log(`get arr ${key}`)\\n\\t\\t\\treturn val\\t\\n\\t\\t},\\n\\t\\tset(newVal) {\\n\\t\\t\\tconsole.log(`set arr ${key}`)\\n\\t\\t\\treturn val = newVal\\n\\t\\t},\\n\\t})\\n});\\n\\n其实，通过下标来改变数组的某一项是能够监听到的，vue自己做了骚操作\\nhttps://segmentfault.com/a/1190000015783546\\n但是，数组的类似于push、pop、shift、unshift....之类的方法监听不到\\n\")])]),e._v(\" \"),r(\"h6\",{attrs:{id:\"利用proxy来代理数组，试试看能不能监听数组变更\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#利用proxy来代理数组，试试看能不能监听数组变更\"}},[e._v(\"#\")]),e._v(\" 利用proxy来代理数组，试试看能不能监听数组变更\")]),e._v(\" \"),r(\"pre\",[r(\"code\",[e._v(\"var arr = [1,2,3,4,5];\\nvar newArr = new Proxy(arr,{\\n\\tget: function (arr, key, receiver) {\\n        console.log(`getting ${key}!`);\\n        return Reflect.get(arr, key, receiver);\\n  \\t},\\n  \\tset: function (arr, key, value, receiver) {\\n    \\tconsole.log(`setting ${key}!`);\\n    \\treturn Reflect.set(arr, key, value, receiver);\\n  \\t}\\n});\\n\")])])])}),[],!1,null,null,null);t.default=n.exports}}]);","extractedComments":[]}