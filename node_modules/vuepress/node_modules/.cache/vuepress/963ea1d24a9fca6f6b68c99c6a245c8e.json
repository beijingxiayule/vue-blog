{"remainingRequest":"/Users/wangyaping/learn/vue-blog/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/wangyaping/learn/vue-blog/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/wangyaping/learn/vue-blog/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/wangyaping/learn/vue-blog/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/wangyaping/learn/vue-blog/docs/blog/20200213.md?vue&type=template&id=30acdbd6&","dependencies":[{"path":"/Users/wangyaping/learn/vue-blog/docs/blog/20200213.md","mtime":1581672429716},{"path":"/Users/wangyaping/learn/vue-blog/node_modules/cache-loader/dist/cjs.js","mtime":1547533956260},{"path":"/Users/wangyaping/learn/vue-blog/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1588736475396},{"path":"/Users/wangyaping/learn/vue-blog/node_modules/cache-loader/dist/cjs.js","mtime":1547533956260},{"path":"/Users/wangyaping/learn/vue-blog/node_modules/vue-loader/lib/index.js","mtime":1588736475396},{"path":"/Users/wangyaping/learn/vue-blog/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1591753789235}],"contextDependencies":[],"result":["var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _vm._m(0)\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"div\", { staticClass: \"content\" }, [\n      _c(\"h3\", { attrs: { id: \"vue-开发规范\" } }, [\n        _c(\n          \"a\",\n          { staticClass: \"header-anchor\", attrs: { href: \"#vue-开发规范\" } },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Vue 开发规范\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h4\", { attrs: { id: \"_1、钩子函数以及组件书写顺序：\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#_1、钩子函数以及组件书写顺序：\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" 1、钩子函数以及组件书写顺序：\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"pre\", [\n        _c(\"code\", [\n          _vm._v(\n            \"- components\\n- props\\n- data\\n- computed\\n- created\\n- mounted\\n- metods\\n- watch\\n\"\n          )\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h4\", { attrs: { id: \"_2、常量以及变量的定义：\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#_2、常量以及变量的定义：\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" 2、常量以及变量的定义：\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"pre\", [\n        _c(\"code\", [\n          _vm._v(\n            \"简单常量：\\n    全部大写，简单的用单个单词或者用_拼接单词\\n    CONST COUNT = 5\\n    const STAR_COUNT = 10\\n    const NEWCAR_URL = 'https://www.newcar.com/'\\n\\n变量：\\n    对于与视图毫无关系的变量，例如url上拼接的id，uuid等，很多参数的话，可以在 created 里面定义一个用于存储公共参数的对象：\\n    eg:\\n        created() {\\n            this.commomParams = {\\n                modelId: getUrlParams(\\\"model_id\\\"),\\n                sign: getUrlParams(\\\"sign\\\"),\\n                ...\\n            }\\n\\n        } \\n\\n    参数不多的情况下,可以直接定义在最外面\\n    eg:\\n        import {Toast, Indicator} from 'mint-ui';\\n        import {getUrlParam} from '../../../utils/constants';\\n        const MODEL_ID = getUrlParam(\\\"model_id\\\");\\n        const SIGN = getUrlParam(\\\"sign\\\");\\n\\n        export default {\\n            name: 'app',\\n            data: function() {\\n                return {\\n                    \\n                };\\n            }\\n        }\\n\"\n          )\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h4\", { attrs: { id: \"_3、元素特性的顺序：\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#_3、元素特性的顺序：\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" 3、元素特性的顺序：\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"pre\", [\n        _c(\"code\", [\n          _vm._v(\n            '原生属性放前面，指令放后面：\\n    - class\\n    - id,ref\\n    - name\\n    - data-*\\n    - src, for, type, href,value,max-length,max,min,pattern\\n    - title, alt，placeholder\\n    - required,readonly,disabled\\n    - is\\n    - v-for\\n    - key\\n    - v-if\\n    - v-else-if\\n    - v-else\\n    - v-show\\n    - v-once\\n    - v-model\\n    - v-bind,:\\n    - v-on,@\\n    - v-html\\n    - v-text\\n\\n    eg：\\n        // bad\\n        <img\\n            v-for=\"(item,index) in reportData.detail.pic\"\\n            class=\"accident-car-img\" \\n            v-lazy=\"item\" \\n            @click=\"handleImgsClick(index)\">\\n\\n        // good\\n        <img\\n            class=\"accident-car-img\" \\n            v-for=\"(item,index) in reportData.detail.pic\"\\n            v-lazy=\"item\" \\n            @click=\"handleImgsClick(index)\">\\n\\n元素里面的函数如果有参数肯定有括号，没有参数的时候统一不要括号：\\n    // bad\\n    <div class=\"back-to-top\" @click=\"backToTop()\">返回顶部</div>\\n\\n    // good\\n    <div class=\"back-to-top\" @click=\"backToTop\">返回顶部</div>\\n'\n          )\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h4\", { attrs: { id: \"_4、指令规范：\" } }, [\n        _c(\n          \"a\",\n          { staticClass: \"header-anchor\", attrs: { href: \"#_4、指令规范：\" } },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" 4、指令规范：\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"pre\", [\n        _c(\"code\", [\n          _vm._v(\n            '指令统一使用缩写：\\na、指令有缩写一律采用缩写形式：\\n    // bad\\n    v-bind:class=\"{\\'fix-top\\'：fixTop}\"\\n    v-on:click=\"scrollTop\"\\n\\n    // good\\n    :class=\"{\\'fix-top\\'：fixTop}\"\\n    @click=\"scrollTop\"\\n\\nb、v-for 循环必须加上 key 属性，在整个 for 循环中 key 需要唯一\\nc、避免 v-if 和 v-for 同时用在一个元素上\\n'\n          )\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h4\", { attrs: { id: \"_5、prop的规范：\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#_5、prop的规范：\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" 5、prop的规范：\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"pre\", [\n        _c(\"code\", [\n          _vm._v(\n            \"a、定义 Prop 的时候应该始终以驼峰格式（camelCase）命名，在父组件赋值的时候使用连接线（-）。这里遵循每个语言的特性，因为在 HTML 标记中对大小写是不敏感的，使用连接线更加友好；而在 JavaScript 中更自然的是驼峰命名。\\n\\n    // bad\\n    props: {\\n        article-status: Boolean\\n    }\\n    <article-item :articleStatus=\\\"true\\\"></article-item>\\n\\n    // good\\n    props: {\\n        articleStatus: Boolean\\n    }\\n    <article-item :article-status=\\\"true\\\"></article-item>\\n\\nb、prop的指定验证要求\\n    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)\\n    propA: Number,\\n    // 多个可能的类型\\n    propB: [String, Number],\\n    // 必填的字符串\\n    propC: {\\n        type: String,\\n        required: true\\n    },\\n    // 带有默认值的数字\\n    propD: {\\n        type: Number,\\n        default: 100\\n    },\\n    // 带有默认值的对象\\n    propE: {\\n        type: Object,\\n        // 对象或数组默认值必须从一个工厂函数获取\\n        default: function () {\\n            return { message: 'hello' }\\n        }\\n    },\\n    // 自定义验证函数\\n    propF: {\\n        validator: function (value) {\\n            // 这个值必须匹配下列字符串中的一个\\n            return ['success', 'warning', 'danger'].indexOf(value) !== -1\\n        }\\n    }\\n}\\n\"\n          )\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h4\", { attrs: { id: \"_6、组件的约束：\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#_6、组件的约束：\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" 6、组件的约束：\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"pre\", [\n        _c(\"code\", [\n          _vm._v(\n            \"组件命名须以大写字母开头：\\n    // bad\\n        components/\\n        |- heading.vue\\n        |- sidebar.vue\\n\\n    // good\\n        components/\\n        |- Heading.vue\\n        |- Sidebar.vue\\n\\n使用组件时：\\n    <my-component-name> 和 <MyComponentName> 都是可接受的。注意，尽管如此，直接在 DOM (即非字符串的模板) 中使用时只有 kebab-case 是有效的。\\n\\n自定义事件时：\\n    触发一个事件： this.$emit('myEvent')\\n    在vue这么定义时，是无效的：\\n    <my-component v-on:my-event=\\\"doSomething\\\"></my-component>\\n    不同于组件和 prop，事件名不会被用作一个 JavaScript 变量名或属性名，所以就没有理由使用 camelCase 或 PascalCase 了。并且 v-on 事件监听器在 DOM 模板中会被自动转换为全小写 (因为 HTML 是大小写不敏感的)，所以 v-on:myEvent 将会变成 v-on:myevent——导致 myEvent 不可能被监听到。\\n\\n    因此，推荐你始终使用 kebab-case（中划线） 的事件名。\\n\"\n          )\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"H5研究：\\n许艺宝：动效和动画：合理的解决方案 & 精细化交互\\n多TAB 长列表左右滑动切换tab保留位置等;\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"pre\", [\n        _c(\"code\", [\n          _vm._v(\n            \"    和APP学习，和app保持交互一直\\n    学习一些炫酷的动效交互，向产品提供方案，然后商量是否可行\\n\\n\\n\\n\\n\\n\\n王亚晖：组件化管理\\n\\n\\n\\n左佳鑫：性能优化\\n\\n\\n未选择的：\\n    H5+ES67+CSS3\\n    CANVAS\\n\"\n          )\n        ])\n      ])\n    ])\n  }\n]\nrender._withStripped = true\n\nexport { render, staticRenderFns }"]}